<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Hao Xi"><meta name="description"><title>Kevin's Blog</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://yoursite.com/"><link rel="alternate" href="/atom.xml" title="Kevin's Blog"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Kevin's Blog</a><ul class="nav"><li class="nav-link"><a href="/" class="active">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/categories/" target="_self">Categories</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/28/warm-up-series-8-calling-conventions/" class="post-link">Warm Up Series (8) – Calling Conventions</a></h2><span class="post-time">Mar 28, 2012</span><div class="post-content"><p>A &quot;calling convention&quot; is the way in which a function is called. The standard <font><font><font size="2"><em><font face="Courier New">__cdecl</font></em></font></font></font> is what has been used up until now, other common ones are <em><font size="2" face="Courier New">__stdcall</font></em>, <em><font size="2" face="Courier New">__fastcall</font></em>, and <em><font size="2" face="Courier New">__thiscall</font></em>, a less common convention used when writing hacks is <em><font size="2" face="Courier New">__declspec(naked)</font></em>.</p>
<h4 id="cdecl-is-the-default-calling-convention-on-most-C-compilers-The-properties-are-as-follows"><a href="#cdecl-is-the-default-calling-convention-on-most-C-compilers-The-properties-are-as-follows" class="headerlink" title="__cdecl is the default calling convention on most C compilers. The properties are as follows:"></a><font><font size="2"><em><font face="Courier New">__cdecl</font></em></font></font> is the default calling convention on most C compilers. The properties are as follows:</h4><ul>
<li>The caller places all the parameters on the stack*   The caller removes the parameters from the stack (often by adding the total size added to the stack pointer)  </li>
</ul>
<p><em><font size="2" face="Courier New">__stdcall</font></em> is another common calling convention. The properties are:</p>
<ul>
<li><p>The caller places all the parameters on the stack*   The called function removes the parameters from the stack, often by using the return instruction with a parameter equal to the number of parameters, &quot;ret xx&quot;  </p>
<p><pre><font size="4"></font></pre><br>The most useful part about <em><font size="2" face="Courier New">__stdcall</font></em> is that it tells a reverse engineer how many parameters are passed to any given function. In cases where no examples of the function being called may be found (possibly because it’s an exported DLL function), it is easier to check the return than to enumerate local variables.</p>
</li>
</ul>
<h4 id="fastcall-is-the-final-common-calling-convention-seen-All-implementations-of-fastcall-pass-parameters-in-registers-although-Microsoft-and-Borland-for-example-use-different-registers-Here-are-the-properties-of-Microsoft’s-fastcall-implementation"><a href="#fastcall-is-the-final-common-calling-convention-seen-All-implementations-of-fastcall-pass-parameters-in-registers-although-Microsoft-and-Borland-for-example-use-different-registers-Here-are-the-properties-of-Microsoft’s-fastcall-implementation" class="headerlink" title="__fastcall is the final common calling convention seen. All implementations of __fastcall pass parameters in registers, although Microsoft and Borland, for example, use different registers. Here are the properties of Microsoft’s __fastcall implementation:"></a><em><font size="2" face="Courier New">__fastcall</font></em> is the final common calling convention seen. All implementations of <em><font size="2" face="Courier New">__fastcall</font></em> pass parameters in registers, although Microsoft and Borland, for example, use different registers. Here are the properties of Microsoft’s <em><font size="2" face="Courier New">__fastcall</font></em> implementation:</h4><ul>
<li>First two parameters are passed in ecx and edx, respectively<em>   Third parameter and on are passed on the stack, as usual</em>   Functions clean up their own stack, if necessary</li>
</ul>
<p>Recognizing a <em><font size="2" face="Courier New">__fastcall</font></em> function is easy: look for ecx and edx being used without being initialized in a function.</p>
<p>A <em><font size="2" face="Courier New">__fastcall</font></em> with no parameters is identical to <font><font size="2"><em><font face="Courier New">__cdecl</font></em></font></font> and <em><font size="2" face="Courier New">__stdcall</font></em> with no parameters, and a <em><font size="2" face="Courier New">__fastcall</font></em> with a single parameter looks like <em><font size="2" face="Courier New">__thiscall</font></em>.</p>
<p>  <pre><font size="4"></font></pre><br>  <font size="2" face="Courier New"><font face="Verdana"></font><strong><em>thiscall</em></strong></font> is very similar to _<font size="2" face="Courier New">stdcall</font>_, except that a pointer to the class whose member is being called is passed in ecx.</p>
<ul>
<li><p>ecx is assigned a pointer to the class whose member is being called<em>   The parameters are placed on the stack, the same as <em><font size="2" face="Courier New">__stdcall</font></em></em>   The function cleans itself up, the same as <em><font size="2" face="Courier New">__stdcall</font></em></p>
<p><pre><font size="4"></font></pre><br><em><font size="2" face="Courier New">__declspec(naked)</font></em> is a Visual Studio-specific convention, can’t really be identified in assembly, since it’s identical to <font><font size="2"><em><font face="Courier New">__cdecl</font></em></font></font> once it reaches assembly. However, the special property of this convention is that the compiler will generate no code in a function. This allows the program, in a __asm{} block, to write everything from preserving registers to allocating local variables and returning. This is useful when patching a jump in the middle of code, since it prevents the function from changing registers without the programmer’s knowledge.</p>
</li>
</ul>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/28/warm-up-series-7-keywords-used-in-c/" class="post-link">Warm Up Series (7) – Keywords used in C++</a></h2><span class="post-time">Mar 28, 2012</span><div class="post-content"><h3 id="1-Storage-Classes"><a href="#1-Storage-Classes" class="headerlink" title="1. Storage Classes"></a><strong>1. Storage Classes</strong></h3><ul>
<li>Storage class specifiers tell compiler the duration and visibility of the variables or objects declared, as well as, where the variables or objects should be stored.    </li>
<li>In C / C++ there are 4 different storage classes available: <em>automatic, external, static and register</em>.</li>
</ul>
<p><strong><em>Automatic Variable - auto</em></strong>     </p>
<ul>
<li>Local variables are variables declared within a function or blocks (after the opening brace, { of the block). Local variables are automatic by default. This means that they come to existence when the function in which it is declared is invoked and disappears when the function ends.     </li>
<li>Automatic variables are declared by using the keyword <em>auto</em>. But since the variables declared in functions are automatic by default, this keyword may be dropped in the declaration as you found in many source codes.     </li>
<li>The same variable names may be declared and used in different functions, but they are only known in the functions in which they are declared. This means, there is no confusion even if the same variables names are declared and used in different functions.     </li>
<li><p>Examples if we want explicitly declare the automatic type:</p>
<blockquote>
<font face="Courier New"><em>auto int x, y, z = 30;<br>auto char firstname;</em></font>  
</blockquote>
</li>
<li><p>Same as:</p>
<blockquote>
<font face="Courier New"><em>int x, y, z = 30;<br>char firstname;</em></font>  

</blockquote>
</li>
</ul>
<p><em><font face="Courier New"></font></em></p>
<p><strong><em>External Variable - extern</em></strong>     </p>
<ul>
<li>External variables are variables that are recognized globally, rather than locally. In other words, once declared, the variable can be used in any line of codes throughout the rest of the program.     </li>
<li>A variable defined outside a function is external. An external variable can also be declared within the function that uses it by using the keyword extern hence it can be accessed by other code in other files.     </li>
<li><p>Program segment example:</p>
<blockquote>
<font face="Courier New"><em>int value1;<br>char name;<br>double value2;<br>//three externally defined variables<br>main()<br>{<br>&#160;&#160;&#160; extern int value1;<br>&#160;&#160;&#160; extern char name;<br>&#160;&#160;&#160; extern double value2;<br>&#160;&#160;&#160; //three externally defined variables<br>&#160;&#160;&#160; //can be accessed from outside of this main()<br>&#160;&#160;&#160; extern value3;<br>&#160;&#160;&#160; //can be accessed from outside of this main()<br>&#160;&#160;&#160; …<br>}</em></font>  
</blockquote>
</li>
<li><p>Note that the group of extern declarations may be omitted entirely if the original definition occurs in the same file and before the function that uses them.    </p>
</li>
<li>Therefore in the above example, the three extern declarations may be dropped. However, including the extern keyword explicitly will allow the function to use external variable even if it is defined later in a file or even in a different file provided both files will be compiled and linked together.</li>
</ul>
<p><strong><em>Static Variable - static</em></strong>     </p>
<ul>
<li>In a single file program, static variables are defined within individual functions that they are local to the function in which they are defined. Static variables are local variables that retain their values throughout the lifetime of the program. In other words, their same (or the latest) values are still available when the function is re-invoked later.     </li>
<li>Their values can be utilized within the function in the same manner as other variables, but they cannot be accessed from outside of their defined function.     </li>
<li>The static has internal linkage (that is not visible from outside) except for the static members of a class that have external linkage. </li>
</ul>
<p><strong><em>Register Variable - register</em></strong>     </p>
<ul>
<li>The above three classes of variables are normally stored in computer memory. Register variables however are stored in the processor registers, where they can be accessed and manipulated faster. Register variables, like automatic variables, are local to the function in which they are declared.     </li>
<li>Defining certain variables to be register variables does not, however, guarantee that they will actually be treated as register variables.     </li>
<li>Registers will be assigned to these variables by compiler so long as they are available. If a register declaration cannot be fulfilled, the variables will be treated as automatic variables. So, it is not a mandatory for the compiler to fulfill the register variables.     </li>
<li>Usually, only register variables are assigned the register storage class. If all things equal, a program that makes use of register variables is likely to run faster than an identical program that uses just automatic variables.</li>
</ul>
<h3 id="2-Constant-Values-const"><a href="#2-Constant-Values-const" class="headerlink" title="2. Constant Values - const"></a><strong>2. Constant Values - const</strong></h3><ul>
<li>In the most basic form, the <em>const</em> keyword specifies that a variable’s value is constant and tells the compiler to prevent the programmer from modifying it.     </li>
<li><p>Example of the pointer declaration using <em>const</em> is shown below:</p>
<blockquote>
<font face="Courier New"><em>//Pointer to constant int<br>int const <em>PtrVar;<br>//Pointer to constant int<br>int const (</em>PtrVar);<br>//Constant pointer to int<br>int <em>const PtrVar;<br>//Constant pointer to int<br>int (</em>const PtrVar);</em></font>  
</blockquote>
</li>
<li><p>Program example:</p>
<blockquote>
<font face="Courier New"><em>//const variable<br>#include &lt;iostream&gt;<br>#include &lt;stdlib.h&gt;<br>int main()<br>{<br>&#160;&#160;&#160; //p = 10 is a constant value, cannot be modified<br>&#160;&#160;&#160; //during the program execution…<br>&#160;&#160;&#160; const int p = 10;<br>&#160;&#160;&#160; cout&lt;&lt;&quot;q = p + 20 = &quot;&lt;&lt;(p + 20)&lt;&lt;&quot; where, p = 10&quot;&lt;&lt;endl;<br>&#160;&#160;&#160; //The following code should generate error, because<br>&#160;&#160;&#160; //we try to modify the constant value…<br>&#160;&#160;&#160; //uncomment, recompile notice the error…<br>&#160;&#160;&#160; //p = 15;<br>&#160;&#160;&#160; //–p;<br>&#160;&#160;&#160; system(&quot;pause&quot;);<br>}</em></font>  
</blockquote>
</li>
<li><p>We can use the <em>const</em> keyword instead of the #define preprocessor directive to define constant values.     </p>
</li>
<li>In C, constant values default to external linkage, so they can appear only in source files but in C++, constant values default to internal linkage, which allows them to appear in header files.     </li>
<li>The <em>const</em> also can be used in pointer declaration. A pointer to a variable declared as <em>const</em> can be assigned only to a pointer that is also declared as <em>const</em>.     </li>
<li><p>Another program segment examples:</p>
<blockquote>
<font face="Courier New"><em>//a const pointer to a variable…<br>#include &lt;iostream&gt;<br>#include &lt;stdlib.h&gt;<br>int main()<br>{<br>&#160;&#160;&#160; //declare the pointers and let they point<br>&#160;&#160;&#160; //to something…<br>&#160;&#160;&#160; //non const pointer…<br>&#160;&#160;&#160; char <em>BuffOne = NULL, </em>BuffTwo = NULL;<br>&#160;&#160;&#160; //a constant pointer…<br>&#160;&#160;&#160; //assign the BuffOne pointer to PtrOne pointer<br>&#160;&#160;&#160; char <em>const PtrOne = BuffOne;<br>&#160;&#160;&#160; //Let it point to some data…<br>&#160;&#160;&#160; </em>PtrOne = ‘z’;<br>&#160;&#160;&#160; cout&lt;&lt;&quot;The value pointed by constant pointer is&quot;&lt;&lt;*PtrOne&lt;&lt;endl;<br>&#160;&#160;&#160; //The following code will generate error, because we try to assign non const pointer to const pointer…<br>&#160;&#160;&#160; //PtrOne = BuffTwo;<br>&#160;&#160;&#160; system(&quot;pause&quot;);<br>&#160;&#160;&#160; return 0;<br>}</em></font>  &gt; <font face="Courier New"><em>//a pointer to a const variable…<br>#include &lt;iostream&gt;<br>#include &lt;stdlib.h&gt;<br>int main()<br>{<br>&#160;&#160;&#160; const char <em>BuffOne = &quot;Testing&quot;;<br>&#160;&#160;&#160; cout&lt;&lt;&quot;The data pointed by BuffTwo is &quot;&lt;&lt;BuffOne&lt;&lt;endl;<br>&#160;&#160;&#160; //The const pointer BuffOne assigned to the<br>&#160;&#160;&#160; //const pointer ThePtr is OK…<br>&#160;&#160;&#160; const char </em>ThePtr = BuffOne;<br>&#160;&#160;&#160; cout&lt;&lt;&quot;The data pointed by ThePtr is &quot;&lt;&lt;ThePtr&lt;&lt;endl;<br>&#160;&#160;&#160; //The following code will generate an error<br>&#160;&#160;&#160; //cannot modify the const….<br>&#160;&#160;&#160; //*ThePtr = ‘z’;<br>&#160;&#160;&#160; system(&quot;pause&quot;);<br>&#160;&#160;&#160; return 0;<br>}           
</em></font>  
</blockquote>
</li>
<li><p>The const declaration also normally used in the definition of a function’s arguments, to indicate it would not change them as shown below making the code clearer and to avoid error. <font face="Courier New"><em>int strlen(const char []); </em></font></p>
</li>
</ul>
<h3 id="3-Constant-Member-Function"><a href="#3-Constant-Member-Function" class="headerlink" title="3. Constant Member Function"></a><strong>3. Constant Member Function</strong></h3><ul>
<li>When declaring a member function with the <em>const</em> keyword, this specifies that it is a read only function that does not modify the object (notice the differences between variable versus object) for which it is called.     </li>
<li>A constant member function cannot modify any data members or call any member functions that are not constant.     </li>
<li>Implicitly, the <em>const</em> has set the ‘can’t modify’ *this pointer. This can be changed by using the mutable (preferred) or _const<em>cast</em> operator.     </li>
<li>Pointer to constant data can be used as function parameters to prevent the function from modifying a parameter passed through a pointer.     </li>
<li>Place the <em>const</em> keyword after the closing parenthesis of the argument list.     </li>
<li><em>const</em> keyword is required in both the declaration and the definition.     </li>
<li><p>Program example:</p>
<blockquote>
<font face="Courier New"><em>//constant member function<br>#include &lt;iostream&gt;<br>#include &lt;stdlib.h&gt;<br>//——–Class declaration part————<br>class Date<br>{<br>&#160;&#160;&#160; int month;<br>public:<br>&#160;&#160;&#160; //we would test the month only…<br>&#160;&#160;&#160; Date (int mnt, int dy, int yr);<br>&#160;&#160;&#160; //A write function, so can’t be const<br>&#160;&#160;&#160; void SetMonth(int mnt);<br>&#160;&#160;&#160; //A read only function declaration<br>&#160;&#160;&#160; int GetMonth() const;<br>}; </em></font><br>   <font face="Courier New"><em><br><br>//——–Class implementation part———<br>Date::Date(int,int,int)<br>{<br>}<br>void Date::SetMonth(int mnt)<br>{<br>&#160;&#160;&#160; //Modify the non const member variable data<br>&#160;&#160;&#160; month = mnt;<br>}<br>//A read only function implementation<br>int Date::GetMonth() const<br>{<br>&#160;&#160;&#160; //Does not modify anything<br>&#160;&#160;&#160; return month;<br>}<br><br>//——-main program————<br>void main()<br>{<br>&#160;&#160;&#160; Date TheDate(7,4,2004);<br>&#160;&#160;&#160; //non const member function, OK<br>&#160;&#160;&#160; TheDate.SetMonth(11);<br>&#160;&#160;&#160; cout&lt;&lt;&quot;Month of the sample date is &quot;&lt;&lt;TheDate.GetMonth()&lt;&lt;endl;<br>&#160;&#160;&#160; //another dummy const object…<br>&#160;&#160;&#160; const Date BirthDate(7,4,1971);<br>&#160;&#160;&#160; //Then try to modify the const object, NOT OK<br>&#160;&#160;&#160; //BirthDate.SetMonth(5);<br>&#160;&#160;&#160; //const member function sending message…<br>&#160;&#160;&#160; BirthDate.GetMonth();<br>&#160;&#160;&#160; //So, the following shouldn’t have the output data…<br>&#160;&#160;&#160; cout&lt;&lt;&quot;Another silly call, the month is &quot;&lt;&lt;BirthDate.GetMonth()&lt;&lt;endl;<br>&#160;&#160;&#160; system(&quot;pause&quot;);<br>}
     </em></font>  
</blockquote>
</li>
<li><p>The const-ness of the function can be disabled by using the <em>mutable</em> keyword.</p>
</li>
</ul>
<h3 id="4-Keyword-volatile"><a href="#4-Keyword-volatile" class="headerlink" title="4. Keyword - volatile"></a><strong>4. Keyword - volatile</strong></h3><ul>
<li>It is a type qualifier used to declare an object or variable value that can be modified by other than the statement in the source codes itself, such as interrupt service routine and memory-mapped I/O port or concurrent thread execution.    </li>
<li>Keep in mind that although we have to concern about these volatile variable or object, most of the compilers nowadays have their own implementation how to handle this situation mainly for Win32 applications.     </li>
<li>For example if you want to create multithreaded program, there are C++ compiler or project settings for multithreaded program. You have to check your compiler documentation.     </li>
<li>When declaring an object to be volatile, we tell the compiler not to make any assumptions concerning the value of the object while evaluating expressions in which it occurs because the value could change at any moment.     </li>
<li>When a name is declared as volatile, the compiler reloads the value from memory each time it is accessed by the program. Volatile codes will not be optimized by compiler to make sure that the value read at any moment is accurate.     </li>
<li>Without optimization, for example permitting the redundant reads, the volatile may have no effect.     </li>
<li>The keyword volatile is used before or after the data type declaration. They cannot appear after the first comma in a multiple variable declaration.&#160; </li>
<li>When volatile is applied to the struct or union, the entire contents of the struct or union become volatile however we can also apply the volatile to the members of struct or union individually.     </li>
<li>volatile also applied to classes and their member functions.</li>
</ul>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/12/preparation-tips-for-a-behavioral-interview/" class="post-link">Preparation Tips for a Behavioral Interview</a></h2><span class="post-time">Mar 12, 2012</span><div class="post-content"><p>(From: <a href="http://jobsearchtech.about.com/od/gettingthejob/a/Interviewing_2.htm" target="_blank" rel="external">http://jobsearchtech.about.com/od/gettingthejob/a/Interviewing_2.htm</a>)</p>
<p>Preparing for a behavior based interview can be daunting. Here are some tips to get started:</p>
<ul>
<li><strong>Be familiar with the job</strong> for which you’re being interviewed. Read the advertisement or job description to identify which personal attributes and behaviors are likely to be key success factors for the role. For Client interviews it is advised that you research the company’s website and any external information about them from business directories etc.<br>Make a note of two or three examples for each personal attribute that will best illustrate your suitability - you may want to bring these into the interview with you as prompts. Remember that different companies and industries may require different personal attributes, even for the same position. For example, ‘self-managing’ can mean very different things to different companies.</li>
<li><strong>Be able to draw from a variety of experiences</strong> that demonstrate your skills and abilities. A good story can also combine work experience with a non-work experience (shows you can use the skill in a variety of settings). Examples may be from your work experience, your personal life or some social or other situation. Of course a unique work situation story (unless otherwise specifically requested) should take priority. Be as open, expressive and succinct as possible about each experience.</li>
<li><strong>Let others help you out </strong>- use examples of quotes from bosses or customers, i.e., &quot;My boss gave me a good performance review, they liked the way I stepped in to get the job done without being told to.&quot; This demonstrates your willingness to accept contribution, your flexibility and teamwork skills.</li>
<li><strong>Think ‘STAR’ - Situation or Task, Action and Result.</strong> There are several variations of this acronym in the recruiting industry, but all of them are intended to provide structure and focus to your answers. When asked about a type of situation, the interviewer is looking at how you responded to it by via a specific example. Using the STAR model you would break your answer into the three segments of; description of the task, then the action you took, and the final measurable result.<br>This makes it easier for the interviewer to visualize and record your specific behavioral responses to specific events and so gain the best impression of your potential future performance. Prepare at least one STAR response for each personal attribute you may be questioned on. Make sure you don’t use the same example for all the attributes.</li>
<li><strong>Use recent examples.</strong> As you will be probed for detail around the situation, it is better to use events in the last 12-18 months as the detail will be clearer in your mind. Be specific as possible about your contribution and the quantitative results achieved. Specific absolute or relative (%) gains in areas such as cost or time savings will give you the interviewer a clearer picture of your abilities. If specific measurable results don’t apply to your example, you might explain how it streamlined processes, empowered others or resolved communication or productivity issues.</li>
<li><strong>Practice telling your stories</strong> until they are vivid and concise, one to three minutes long. An interview can be likened to a marketing activity, where you are the brand. You will only get an interview because your resume and past roles suggest that you have the appropriate technical skills set (your attributes). Often what separates you from the other candidates at the interview stage is the interviewer’s belief in how you will fit into the company’s culture and specific IT team (your personal benefits).<br>Remember, you are selling your technical AND personal skills. Being able to communicate your adaptability and relatedness at an interview is essential to becoming the leading candidate. This ‘story telling practice’ is an important preparation tool to assist you in creating a natural flow to your stories so that the interviewer can focus on your potential benefit to the client.</li>
<li><strong>Ask to come back to the question.</strong> If you are stuck for an answer to a particular question, it is reasonable to ask the interviewer if you may move on to the next one and you’ll come back it.</li>
</ul>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/09/warm-up-series-6-knowledge-of-heap-in-windows/" class="post-link">Warm Up Series (6) – Knowledge of Heap in Windows</a></h2><span class="post-time">Mar 9, 2012</span><div class="post-content"><font size="2"><strong>1. 堆内存管理基础——转自《</strong></font><a href="http://book.51cto.com/art/200812/100341.htm" target="_blank" rel="external"><strong>软件调试</strong></a><strong>/第23章<font size="2"></font><font size="2">》</font></strong><br><br><font size="2">堆是内存管理功能向应用软件提供服务的一种方式。通过堆，内存管理器将一块较大的内存空间委托给堆管理器来管理。堆管理器将大块的内存分割成不同大小的很多个小块来满足应用程序的需要。应用程序的内存需求通常是频繁而且零散的，如果把这些请求都直接传递给位于内核中的内存管理器，那么必然影响系统的性能。有了堆管理器，内存管理器就只需要处理大规模的分配请求。这样做不仅可以减轻内存管理器的负担，也可以大大缩短应用程序申请内存所需的时间，提高程序的性能。下图画出了Windows系统中实现的多级内存分配体系。</font>

<p><a href="http://new.51cto.com/files/uploadimg/20081222/134510209.jpg" target="_blank" rel="external"><font size="2"><img src="http://images.51cto.com/files/uploadimg/20081222/134510209.jpg" alt=""></font></a><font size="2"></font></p>
<font size="2">图中，我们使用不同类型的箭头来代表不同层次的内存分配方法。具体来说，<u>用户态的代码应该调用虚拟内存分配API来从内存管理器分配内存</u>。虚拟内存API包括VirtualAlloc、VirtualFree、VirtualLock、VirtualUnlock、VirtualProtect、VirtualQuery等。内核态的代码可以调用以上API所对应的内核函数，比如NtAllocateVirtualMemory、NtProtectVirtualMemory等。</font>

<font size="2">为了满足内核空间中的驱动程序等内核态代码的内存分配需要，Windows的内核模块中实现了一系列函数来提供内存&quot;零售&quot;服务，为了与用户空间的堆管理器相区别，我们把这些函数统称为池管理器。池管理器公开了一组驱动程序接口（DDI）以向外提供服务，包括ExAllocatePool、ExAllocatePoolWithTag、ExFreePool等。</font>

<font size="2">与内核模块中的池管理器类似，在NTDLL.DLL中实现了一个通用的堆管理器，目的为用户态的应用程序提供内存服务，通常被称为<u>Win32堆管理器</u>。SDK中公开了一组API来访问Win32堆管理器的功能，比如HeapAlloc、HeapFree等。</font>

<font size="2">为了支持C的内存分配函数和C++的内存分配运算符，C运行库会创建一个专门的堆供这些函数使用，通常称为<u>CRT堆</u>。根据分配堆块的方式不同，CRT堆有三种工作模式：SBH(Small Block Heap)模式、旧SBH模式和系统模式(System Heap)，当创建CRT堆时，会选择其中的一种。对于前两种模式，CRT堆会使用<u>虚拟内存分配API</u>从内存管理器批发大的内存块过来，然后分割成小的堆块满足应用程序的需要。对于系统模式，CRT堆只是把堆块分配请求转发给它所基于的Win32堆，因此处于系统模式的CRT堆只是对Win32堆的一种简单封装，在原来的基础上又增加了一些附加的功能。</font>

<font size="2">应用程序开发商也可以实现自己的堆管理器，只要通过虚拟内存API从内存管理器&quot;批发&quot;内存块过来后提供给自己的客户代码使用，例如.NET里面的托管堆。</font>

<font size="2"></font>

<font size="2"></font>

<p><font size="2"><strong>2. CRT堆的分配使用——转自《<a href="http://clkrst.itpub.net/post/137/41162" target="_blank" rel="external">在一个模块中分配的内存在另外一个模块释放？</a></strong></font><strong><font size="2">》</font></strong></p>
<p>在Linux下，每个进程只有一个堆，在任何一个动态库模块中通过new或者malloc来分配内存的时候都是从这个唯一的堆中分配的，那么自然你在其它随便什么地方都可以释放。但是在Win下面，问题变得复杂了：<br><strong>1. </strong>Windows允许一个进程中有多个堆，那么这样就需要指明一块内存要在哪个堆上分配，Win32的HeapAlloc函数就是这样设计的，给出一个堆的句柄，给出一个大小，然后返回一个指针。每个进程都至少有一个主堆，可以通过GetProcessHeap来获得，其它的堆，可以通过GetProcessHeaps取到。同样，内存释放通过HeapFree来完成，还是需要指定一个堆。<br><strong>2. </strong>这样的设计比较灵活，但是问题在于，每次分配内存的时候就必须要显式的指定一个堆，对于CRT中的new/malloc，需要特殊处理。VC的CRT创建了一个单独的堆，叫做<strong>crtheap，它对于用户是看不见的，但是在new/malloc的实现中，都是用HeapAlloc在这个</strong>crtheap上分配的，也就是说malloc(size)基本上可以认为等同于HeapAlloc(__crtheap, size)（当然实际上CRT内部还要维护一些内存管理的数据结构，所以并不是每次malloc都必然会触发HeapAlloc），这样new/malloc就和Windows的堆机制吻合了。<br><strong>3. </strong>如果一个进程需要动态库支持，系统在加载dll的时候，在dll的启动_DllMainCRTStartup中，会创建这个CRT堆，所以理论上有多少个dll，就有多少个CRT堆。最后主进程的mainCRTStartup 中还会创建一个为主进程服务的CRT堆。（由于顺序总是先加载dll，然后才启动main进程，所以各个dll的CRT堆地址比较小，而主进程的CRT堆地址比较大，当然排在最前面的堆是每个进程的主堆。）<br><strong>4.</strong>从上面的分析中可以看出，对于CRT来说，由于每个dll都有自己的堆，所以每个dll通过new/malloc分配的内存都是在自己dll内部的那个堆上用HeapAlloc来分配的，而如果你想在其它模块中释放，那么在释放的时候HeapFree就会失败了，因为各个模块的CRT堆是不一样的。</p>
<p>在Windows下，一个进程存在着多个堆，除了一个主堆外，还有很多的CRT堆，用来处理通过C/C++的运行库进行的内存操作。所以使用new/malloc来分配的内存实际上都是局部的，可以在多个dll中共享，但是却必须是谁申请谁释放。当然如果在dll内部使用HeapAlloc(GetProcessHeap(), size)来分配的内存是可以在dll以外释放的，因为这时内存分配在全局的主堆上，而不是分配在dll自己的CRT堆上。</p>
<p>&#160;</p>
<p><strong>3. CRT堆的调试使用——转自《深入解析Win32 CRT 调试堆 (<a href="http://www.cppblog.com/legendlee/archive/2009/10/20/99054.html" target="_blank" rel="external">上</a>) (<a href="http://www.cppblog.com/legendlee/archive/2009/10/23/99278.html" target="_blank" rel="external">下</a>)》</strong></p>
<p>调试版本的CRT堆更关注对于堆错误的定位, 它通过以下三种手法实现以上诉求:</p>
<p><strong>1. </strong>用守护内存块包围新分配的内存, 这样就可以侦测到缓冲过载和欠载. 所谓守护内存块就是一系列被填充为0xfd的内存字节, 又被称为”无主之地”. 0xfd意为Fences(译注: 栅栏)</p>
<p><strong>2. </strong>用一个特殊的值(0xcd)初始化新申请的内存. 0xcd意为Clean Memory.</p>
<p><strong>3. </strong>同时用一个特殊的值填充(0xdd) 被释放的内存. 0xdd意为Dead Memory.</p>
<p>CDH(CRT Debug Heap)将大部分工作交由堆函数HeapAlloc()和HeapFree()完成, 每进程4Gb的虚地址空间的分块和管理是由Kernel32.dl中的Win32堆自己完成的. </p>
<p>当你调用malloc(8)分配8字节的内存时, CDH会调用HeapAlloc()申请48字节的内存, 额外的40字节被用来存放内存块的额外信息—-比如调用malloc()的源文件和行号, 以及指向上/下一个内存块的指针.在后面的列表中,<u> 所有的CRT调试信息均被标记为红色</u>.</p>
<p>HeaoAlloc()本身也需要记录簿记(bookkeeping)信息, 事实上,一个HeaoAlloc()调用会在进程地址空间里保留80字节内存, 其中8字节的簿记信息出现在真正使用的40字节之前, 剩下的32字节在真正使用的40字节之后.在下面的列表里, <u>Win32堆簿记信息被标记为灰色</u>.</p>
<p>CRT取得40字节的内存块后会填入自己的簿记信息. 头两个WORD用来存放直向”前一个”和”后一个”CRT堆内存块的指针. 这里的前后不能从字面去理解, 因为所谓指向”后一个”内存块的指针事实上指向的是时间顺序上紧邻本内存块之前分配的内存块, 相应的, 指向“前一个”的指针指向的是下一个将被分配的内存块. 之所以这样命名, 是因为内存块链表是从最后分配的内存块开始的. 同时, 为了使堆检查代码能遍历每个内存块, CDH还保存着第一块和最后一块内存的地址(_pFirstBlock和_pLastBlock).</p>
<p>如果调用malloc()代码所在的文件名和行号是已知的, 它们将被被保存在第三第四个字中, 紧接着下面一个字表示本块申请了多少字节内存. 再下面一个字是类型域, 等于1表示new或malloc()分配的普通块, 2表示CRT分配的供内部使用的块. 0表示已经被用户释放但是还未归还给Win32堆的块通常来说, 新申请的内存块本位置等于1. 最后一块是计数器, 每执行一次内存分配计数器加1.</p>
<p>通过malloc()得到的8字节内存无用内存包围. 这些空内存被填充为0xfd, 当整个内存块被free()时, CRT会检查这些空内存存放的值是否仍然是0xfd. 如果值改变了, 说明程序有错误存在. 真正被使用的8字节内存被初始化为0xcd, 如果你的对象中间出现连续的0xcd, 那么你一定是忘记了初始化一些东西.</p>
<p>当你调用free()释放上述8字节的内存时, CRT首先会用0xdddddddd填充全部48字节的内存块(包括簿记信息), 这样就可以通过检查这块内存的值获知这块内存在释放后是否又被写入过(比如使用野指针写内存).</p>
<p>接下来, CRT通常会调用HeapFree()函数将本内存块归还给win32堆, win32堆会将本内存块填充为0xFEEEFEEE. 注意, CRT并不维护”空闲块列表”, 这些都由HeapFree()来做(译注: 也就是说空闲列表是由Win32 堆来维护的). 但是, 你可以让CRT不把被释放的内存块归还给Win32堆 (译注: 也就是不调用HeapFree()), 方法是将_CRTDBG_DELAY_FREE_MEM_DF传递给_CrtSetDbgFlag(), 这在你跟踪野指针错误时将会派上用场, 在这种情况下, 内存不会被复用, 所以释放过的内存的值必然是0xdddddddd, 除非你对释放过的内存执行了写操作. 你可以调用_CrtCheckMemory()检查释放过的内存是否被篡改.(译注: 这个函数缺省情况下需要显式调用, 你也可以将_CRTDBG_CHECK_ALWAYS_DF传递给_CrtSetDbgFlag(), 这样每次分配和释放内存时都会调用_CrtCheckMemory())</p>
<p><strong>一个例子:</strong></p>
<p>下面是调用p = malloc(8)然后调用free(p)的过程中内存的变化表, malloc(8)返回的指针为0x00321000, 我列出了偏移后的内存值, 以便你找到你自己分配的内存信息.<br> <a href="http://kevinxi.files.wordpress.com/2012/03/image4.png" target="_blank" rel="external"><img src="http://kevinxi.files.wordpress.com/2012/03/image_thumb4.png" alt="image" title="image"></a></p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/08/warm-up-series-5-template-in-cpp-and-csharp/" class="post-link">Warm Up Series (5) – Template in Cpp and CSharp</a></h2><span class="post-time">Mar 8, 2012</span><div class="post-content"><p><strong><font size="2" face="Verdana">1. C++模板的介绍</font></strong></p>
<font size="2" face="Verdana">C++模板主要包括类（包括class和union）模板以及函数模板。编译器在编译期间会对模板进行特化，根据不同的模板实参为每个泛型类型实例化一个强类型。M个泛型类型，N个模板实参，编译后将产生M x N个强类型。</font>

<font size="2" face="Verdana">C++模板的实例化是迟钝的，即只有在模板被实例化并使用时，才会真正的创建相关的特化类、特化函数。C++泛型的优点是灵活、高性能、易扩展；缺点是容易导致代码膨胀，过分特化会出现很复杂的函数名，给调试造成了不便；另外，C++模板在不同物理实现之间不能共享实例化的强类型（如组件A和组件B不能共享std::vector&lt;int&gt;）。</font>

<p><strong><font size="2" face="Verdana">2. C++模板的使用</font></strong><br>  <div style="border-bottom:silver 1px solid;text-align:left;border-left:silver 1px solid;line-height:12pt;background-color:#f4f4f4;width:97.5%;font-family:&#039;direction:ltr;max-height:200px;font-size:8pt;overflow:auto;border-top:silver 1px solid;cursor:text;border-right:silver 1px solid;margin:20px 0 10px;padding:4px;" id="codeSnippetWrapper">   <div style="text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;padding:0;" id="codeSnippet">     <pre style="text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;"><span style="color:#606060;" id="lnum1">   1:</span> <span style="color:#008000;">//template function.</span></pre><br><!--CRLF--></div></div></p>
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum2&quot;&gt;   2:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#0000ff;&quot;&gt;class&lt;/span&gt; T&amp;gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum3&quot;&gt;   3:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;void&lt;/span&gt; swap(T &amp;amp;a, T &amp;amp;b)&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum4&quot;&gt;   4:&lt;/span&gt; {&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum5&quot;&gt;   5:&lt;/span&gt;     T temp = a;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum6&quot;&gt;   6:&lt;/span&gt;     a = b;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum7&quot;&gt;   7:&lt;/span&gt;     b = temp;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum8&quot;&gt;   8:&lt;/span&gt; };&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum9&quot;&gt;   9:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum10&quot;&gt;  10:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//template class&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum11&quot;&gt;  11:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#0000ff;&quot;&gt;class&lt;/span&gt; T&amp;gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum12&quot;&gt;  12:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;class&lt;/span&gt; Arrary&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum13&quot;&gt;  13:&lt;/span&gt; {&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum14&quot;&gt;  14:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;private&lt;/span&gt;:&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum15&quot;&gt;  15:&lt;/span&gt;     T* ar;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum16&quot;&gt;  16:&lt;/span&gt;     &lt;span style=&quot;color:#0000ff;&quot;&gt;int&lt;/span&gt; l;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum17&quot;&gt;  17:&lt;/span&gt;     ...&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum18&quot;&gt;  18:&lt;/span&gt; };&lt;/pre&gt;
</code></pre><!--CRLF--><br><br><br><font size="2" face="Verdana">实例化可以分为<strong>显示实例化</strong>、<strong>隐式实例化</strong>；显示的实例化通过指定某一特定类型，使编译器强制的生成该类型的实例化代码；隐式实例化则是编译器通过对代码调用的解析，根据模板的使用情况生成相应的实例化代码；隐式实例化类模板时，同时也实例化了模板的每个成员声明，但并没有实例化相应的定义，然而存在例外：如果类模板包含了一个<u>匿名的union</u>，那么该union定义的成员同时也被实例化了；作为实例化类模板的结果，<u>虚函数</u>的定义可能被实例化，也可能没有，这依赖于具体的实现。 </font><br><br><div style="border-bottom:silver 1px solid;text-align:left;border-left:silver 1px solid;line-height:12pt;background-color:#f4f4f4;width:97.5%;font-family:&#039;direction:ltr;max-height:200px;font-size:8pt;overflow:auto;border-top:silver 1px solid;cursor:text;border-right:silver 1px solid;margin:20px 0 10px;padding:4px;" id="codeSnippetWrapper"><br>  <div style="text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;padding:0;" id="codeSnippet"><br>    <pre style="text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;"><span style="color:#606060;" id="lnum1">   1:</span> <span style="color:#008000;">//explicit instantiation.</span></pre><br><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum2&quot;&gt;   2:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;template&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;void&lt;/span&gt; swap&amp;lt;&lt;span style=&quot;color:#0000ff;&quot;&gt;int&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#0000ff;&quot;&gt;int&lt;/span&gt; &amp;amp;a, &lt;span style=&quot;color:#0000ff;&quot;&gt;int&lt;/span&gt; &amp;amp;b); &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum3&quot;&gt;   3:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;template&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;class&lt;/span&gt; Array&amp;lt;&lt;span style=&quot;color:#0000ff;&quot;&gt;int&lt;/span&gt;&amp;gt;; &lt;/pre&gt;
</code></pre><!--CRLF--></div><br></div><br><br><font size="2" face="Verdana">那么也有一种情况，比如我们希望给job类型提供一份特殊的实例化代码，这就需要使用模板的<strong>显示具体化</strong>，使编译器下面的实现，而不是通过上面的模板实例化。</font><br><br><div style="border-bottom:silver 1px solid;text-align:left;border-left:silver 1px solid;line-height:12pt;background-color:#f4f4f4;width:97.5%;font-family:&#039;direction:ltr;max-height:200px;font-size:8pt;overflow:auto;border-top:silver 1px solid;cursor:text;border-right:silver 1px solid;margin:20px 0 10px;padding:4px;" id="codeSnippetWrapper"><br>  <div style="text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;padding:0;" id="codeSnippet"><br>    <pre style="text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;"><span style="color:#606060;" id="lnum1">   1:</span> <span style="color:#008000;">//explicit specialization.</span></pre><br><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum2&quot;&gt;   2:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;template&lt;/span&gt;&amp;lt;&amp;gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;void&lt;/span&gt; swap&amp;lt;job&amp;gt;(job &amp;amp;a, job &amp;amp;b)&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum3&quot;&gt;   3:&lt;/span&gt; {&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum4&quot;&gt;   4:&lt;/span&gt;     &lt;span style=&quot;color:#0000ff;&quot;&gt;int&lt;/span&gt; salary = a.salary;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum5&quot;&gt;   5:&lt;/span&gt;     a.salary = b.salary;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum6&quot;&gt;   6:&lt;/span&gt;     b.salary = salary;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum7&quot;&gt;   7:&lt;/span&gt; };&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum8&quot;&gt;   8:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;template&lt;/span&gt;&amp;lt;&amp;gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;class&lt;/span&gt; Array&amp;lt;job&amp;gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum9&quot;&gt;   9:&lt;/span&gt; {&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum10&quot;&gt;  10:&lt;/span&gt;     ...&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum11&quot;&gt;  11:&lt;/span&gt; };&lt;/pre&gt;
</code></pre><p><!--CRLF--></p></div><br></div><p></p>
<font size="2"><font face="Verdana"><strong>3. C++模板实例化详解</strong> （请参考《</font></font><a href="http://blog.csdn.net/flowshell/article/details/6285711" target="_blank" rel="external"><font size="2" face="Verdana">C++模板实例化</font></a><font size="2" face="Verdana">》）</font>

<font size="2" face="Verdana">略。</font>

<font size="2" face="Verdana"><br><br><em> </em> *<br></font>

<p><strong><font size="2" face="Verdana">1. C#泛型的介绍</font></strong></p>
<font size="2" face="Verdana">C#的模板包括接口模板、类模板、成员函数模板。正确的说，C#的模板应该是指CLR的泛型，所以C++ CLR的模板实现和C#是一模一样的。在介绍C#泛型之前，让我们先看下Java的泛型实现；Java的泛型采用了代码共享技术，所有的实例化类型共享同一套强类型的代码。如List&lt;int&gt;和List&lt;string&gt;共享同一套强类型的代码List&lt;Object&gt;，这样实现有效的减少了代码生成量，但是因为涉及到</font><a href="http://www.cnblogs.com/huashanlin/archive/2007/05/16/749359.html" target="_blank" rel="external"><font size="2" face="Verdana">装箱、拆箱</font></a><font size="2" face="Verdana">，效率低且不够灵活。</font>

<font size="2" face="Verdana"></font>

<h5 id=""><a href="#" class="headerlink" title=""></a><font face="Verdana"></font></h5><font size="2" face="Verdana"></font>

<p><strong><font size="2" face="Verdana">2. C#泛型的实现</font></strong></p>
<font size="2" face="Verdana">C#的模板综合了C++和Java的泛型技术。采用了两阶段延迟特化的方式，从C#源码到IL的静态编译采用Java的代码共享思想，只生成一套抽象的IL代码，在CLR运行时JIT编译时，将IL的抽象代码即时编译，根据每个特化实参生成一个特化的强类型，如图：</font>

<font size="2" face="Verdana"><img src="http://www.99inf.net/SoftwareDev/UploadFiles_9259/200708/20078119191749.bmp" alt=""></font>

<font size="2" face="Verdana">C#的泛型兼备了C++模板和Java泛型的优点，代码简洁方便重用。值得一提的是，CLR对于引用类型，其泛型的工作方式略有不同。第一次使用任何引用类型构造泛型类型时，运行库会创建<strong>专用泛型类型</strong>，用对象引用替换IL中的参数。然后，每次使用引用类型实例化构造类型时，无论引用类型的具体类型是什么，运行库都会重用以前创建的泛型类型的专用版本。之所以可以这样，是因为所有引用的大小相同。</font>

<font size="2" face="Verdana">假设您有两个引用类型Customer和Order，并且您创建了Customer类型的一个泛型实例：Stack&lt;Customer&gt; customers；在此情况下，运行库生成Stack&lt;T&gt;类的一个专用版本，该版本不是存储数据，而是存储稍后将填写的对象引用。假设下一行代码创建另一个引用类型的堆栈泛型实例：Stack&lt;Order&gt; orders；不同于值类型，对于Order类型不创建Stack&lt;T&gt;类的另一个专用版本，而是创建Stack&lt;T&gt;类专用版本的一个实例，并将Order变量设置为引用它。因为引用类型的数量会随程序的不同而大幅变化，C#泛型将编译器为引用类型泛型类创建的专用类的数量减小到一个，大幅减少了代码量。</font>

<font size="2" face="Verdana"><br><br><em> </em> *<br></font>

<font size="2"><font face="Verdana"><strong>1.</strong> <strong>C++和C#泛型模型对比</strong></font></font>

<font size="2" face="Verdana">从整体上来说，因为C#为程序员提供了一致的编程方式，而且它在泛型编程的实现上借鉴了C++，所以相对C++，C#的泛型实现更简单、直接，但与此同时，C#在泛型实现并没有C++强大。下面是正对C++和C#在泛型实现方面的一个简单的对比：</font>

<p><strong><font size="2" face="Verdana"></font></strong></p>
<p><a href="http://kevinxi.files.wordpress.com/2012/03/image3.png" target="_blank" rel="external"><font size="2" face="Verdana"><img src="http://kevinxi.files.wordpress.com/2012/03/image_thumb3.png" alt="image" title="image"></font></a></p>
<font size="2" face="Verdana"><strong>2. 《</strong></font><a href="http://msdn.microsoft.com/zh-cn/library/c6cyy67b(v=vs.80" target="_blank" rel="external"><font size="2" face="Verdana"><strong>C++ 模板和 C# 泛型之间的区别</strong></font></a>.aspx)<font size="2" face="Verdana"><strong>》选自MSDN</strong></font>

<font size="2" face="Verdana">C#泛型和C++模板都是用于提供参数化类型支持的语言功能。然而，这两者之间存在许多差异。在语法层面上，C#泛型是实现参数化类型的更简单方法，不具有C++模板的复杂性。此外，C#并不尝试提供C++模板所提供的所有功能。在实现层面，主要区别在于，C#泛型类型替换是在运行时执行的，从而为实例化的对象保留了泛型类型信息。有关更多信息，请参见</font><a href="http://msdn.microsoft.com/zh-cn/library/f4a6ta2h(v=vs.80" target="_blank" rel="external"><font size="2" face="Verdana">运行库中的泛型（C# 编程指南）</font></a>.aspx)<br><br><font size="2">以下是C#泛型和C++模板之间的主要差异：</font>

<ul>
<li><font size="2" face="Verdana">C#泛型未提供与C++模板相同程度的灵活性。例如，尽管在C#泛型类中可以调用用户定义的运算符，但不能调用算术运算符。 </font></li>
<li><font size="2" face="Verdana">C#不允许非类型模板参数，如template C&lt;int i&gt;{}。 </font></li>
<li><font size="2" face="Verdana">C#不支持显式专用化，即特定类型的模板的自定义实现。 </font></li>
<li><font size="2" face="Verdana">C#不支持部分专用化：类型参数子集的自定义实现。 </font></li>
<li><font size="2" face="Verdana">C#不允许将类型参数用作泛型类型的基类。 </font></li>
<li><font size="2" face="Verdana">C#不允许类型参数具有默认类型。 </font></li>
<li><font size="2" face="Verdana">在C#中，尽管构造类型可用作泛型，但泛型类型参数自身不能是泛型。C++却是允许模板参数。 </font></li>
<li><font size="2" face="Verdana">C++允许那些可能并非对模板中的所有类型参数都有效的代码，然后将检查该代码中是否有用作类型参数的特定类型。C#要求相应地编写类中的代码，使之能够使用任何满足约束的类型。例如，可以在C++中编写对类型参数的对象使用算术运算符+和-的函数，这会在使用不支持这些运算符的类型来实例化模板时产生错误。C#不允许这样；唯一允许的语言构造是那些可从约束推导出来的构造。 </font>

</li>
</ul>
<font size="2" face="Verdana"></font></div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/07/sum1n-problem/" class="post-link">SUM(1/N!) problem</a></h2><span class="post-time">Mar 7, 2012</span><div class="post-content"><p>Hello, Anton</p>
<p>Here is my solution of the <a href="http://jetcracker.wordpress.com/2012/03/07/mpi-calculating-sum/" target="_blank" rel="external">SUM(1/N!)</a> problem, as for the low accuracy of a 32bit double value, there is no need to calculate 1/N! when N &gt;= 178.</p>
<p><u><em>Sample Code</em></u><br>  <div style="border-bottom:silver 1px solid;text-align:left;border-left:silver 1px solid;line-height:12pt;background-color:#f4f4f4;width:97.5%;font-family:&#039;direction:ltr;max-height:800px;font-size:8pt;overflow:auto;border-top:silver 1px solid;cursor:text;border-right:silver 1px solid;margin:20px 0 10px;padding:4px;" id="codeSnippetWrapper">   <div style="text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;padding:0;" id="codeSnippet">     <pre style="text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;"><span style="color:#606060;" id="lnum1">   1:</span> <span style="color:#008000;">//<em>QUESTION</em></span></pre><br><!--CRLF--></div></div></p>
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum2&quot;&gt;   2:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//Calculate the SUM(1/N!), this problem is from Anton&apos;s blog, see:&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum3&quot;&gt;   3:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//http://jetcracker.wordpress.com/2012/03/07/mpi-calculating-sum/&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum4&quot;&gt;   4:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum5&quot;&gt;   5:&lt;/span&gt; &lt;span style=&quot;color:#cc6633;&quot;&gt;#include&lt;/span&gt; &amp;lt;stdio.h&amp;gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum6&quot;&gt;   6:&lt;/span&gt; &lt;span style=&quot;color:#cc6633;&quot;&gt;#include&lt;/span&gt; &amp;lt;omp.h&amp;gt; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum7&quot;&gt;   7:&lt;/span&gt; &lt;span style=&quot;color:#cc6633;&quot;&gt;#include&lt;/span&gt; &amp;lt;ctime&amp;gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum8&quot;&gt;   8:&lt;/span&gt; &lt;span style=&quot;color:#cc6633;&quot;&gt;#include&lt;/span&gt; &amp;lt;cmath&amp;gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum9&quot;&gt;   9:&lt;/span&gt; &lt;span style=&quot;color:#cc6633;&quot;&gt;#include&lt;/span&gt; &amp;lt;cstdlib&amp;gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum10&quot;&gt;  10:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum11&quot;&gt;  11:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//threads&apos; number set to openmp.&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum12&quot;&gt;  12:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//#define NUMBER_THREADS 4&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum13&quot;&gt;  13:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum14&quot;&gt;  14:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//*FACTORIAL*&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum15&quot;&gt;  15:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//Theory 1: While N &amp;gt;= 178, the value of 1/N! would be nearly to 0 and won&apos;t be &lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum16&quot;&gt;  16:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//            saved as &apos;double&apos; in 32bit machine, so it is actually a 1ms task.&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum17&quot;&gt;  17:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//Theory 2: 1/(N-1)! can be used to calculate 1/N! by multiply 1/N.&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum18&quot;&gt;  18:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;double&lt;/span&gt; factorial()&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum19&quot;&gt;  19:&lt;/span&gt; {&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum20&quot;&gt;  20:&lt;/span&gt;     &lt;span style=&quot;color:#0000ff;&quot;&gt;int&lt;/span&gt; n = 177;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum21&quot;&gt;  21:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum22&quot;&gt;  22:&lt;/span&gt;     &lt;span style=&quot;color:#0000ff;&quot;&gt;double&lt;/span&gt; factor = 1;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum23&quot;&gt;  23:&lt;/span&gt;     &lt;span style=&quot;color:#0000ff;&quot;&gt;double&lt;/span&gt; retval = 1;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum24&quot;&gt;  24:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum25&quot;&gt;  25:&lt;/span&gt;     &lt;span style=&quot;color:#008000;&quot;&gt;//#pragma omp parallel for&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum26&quot;&gt;  26:&lt;/span&gt;     &lt;span style=&quot;color:#0000ff;&quot;&gt;for&lt;/span&gt; (&lt;span style=&quot;color:#0000ff;&quot;&gt;int&lt;/span&gt; i = 2; i &amp;lt;= n; i++)&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum27&quot;&gt;  27:&lt;/span&gt;     {&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum28&quot;&gt;  28:&lt;/span&gt;         factor *= (1.0 / (&lt;span style=&quot;color:#0000ff;&quot;&gt;double&lt;/span&gt;)i);&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum29&quot;&gt;  29:&lt;/span&gt;         retval += factor;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum30&quot;&gt;  30:&lt;/span&gt;     }&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum31&quot;&gt;  31:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum32&quot;&gt;  32:&lt;/span&gt;     &lt;span style=&quot;color:#0000ff;&quot;&gt;return&lt;/span&gt; retval;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum33&quot;&gt;  33:&lt;/span&gt; }&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum34&quot;&gt;  34:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum35&quot;&gt;  35:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//*TEST MAIN*&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum36&quot;&gt;  36:&lt;/span&gt; &lt;span style=&quot;color:#008000;&quot;&gt;//Caculate the result, and then print out to console.&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum37&quot;&gt;  37:&lt;/span&gt; &lt;span style=&quot;color:#0000ff;&quot;&gt;void&lt;/span&gt; main()&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum38&quot;&gt;  38:&lt;/span&gt; {    &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum39&quot;&gt;  39:&lt;/span&gt;     clock_t start = clock();&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum40&quot;&gt;  40:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum41&quot;&gt;  41:&lt;/span&gt;     &lt;span style=&quot;color:#008000;&quot;&gt;//setup the threads number.&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum42&quot;&gt;  42:&lt;/span&gt;     &lt;span style=&quot;color:#008000;&quot;&gt;//omp_set_num_threads(NUMBER_THREADS);&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum43&quot;&gt;  43:&lt;/span&gt;     &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum44&quot;&gt;  44:&lt;/span&gt;     &lt;span style=&quot;color:#008000;&quot;&gt;//calculate the result of sum.&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum45&quot;&gt;  45:&lt;/span&gt;     printf(&lt;span style=&quot;color:#006080;&quot;&gt;&amp;quot;SUM(1/N!): %.15f\n&amp;quot;&lt;/span&gt;, factorial());&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum46&quot;&gt;  46:&lt;/span&gt;&amp;#160; &lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum47&quot;&gt;  47:&lt;/span&gt;     &lt;span style=&quot;color:#008000;&quot;&gt;//print the executing period.&lt;/span&gt;&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:#f4f4f4;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum48&quot;&gt;  48:&lt;/span&gt;     printf(&lt;span style=&quot;color:#006080;&quot;&gt;&amp;quot;Total execute: %ldms\n&amp;quot;&lt;/span&gt;, clock() - start);&lt;/pre&gt;
</code></pre><!--CRLF-->
<pre><code>&lt;pre style=&quot;text-align:left;line-height:12pt;background-color:white;width:100%;font-family:&amp;#039;direction:ltr;color:black;font-size:8pt;overflow:visible;border-style:none;margin:0;padding:0;&quot;&gt;&lt;span style=&quot;color:#606060;&quot; id=&quot;lnum49&quot;&gt;  49:&lt;/span&gt; }&lt;/pre&gt;
</code></pre><p><!--CRLF--><br></p>
<p>And here is the result of execution:</p>
<blockquote>
<font face="Courier New">SUM(1/N!): 1.718281828459046<br><br>Total execute: 1ms</font>

</blockquote>
<p>If you use a hi-accuracy float type, then you might need to parallelize the code, but as for ‘double’ type here, such algorithm should be fast enough.</p>
<p>Thanks!</p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/04/warm-up-series-4-memory-allocation-in-csharp/" class="post-link">Warm Up Series (4) – Memory Allocation in CSharp</a></h2><span class="post-time">Mar 4, 2012</span><div class="post-content"><p>在写完上一篇文章后，开始联想到.NET的内存管理机制，于是继续Google出一些文章，大概对C#中的内存管理有了了解。C#的内存管理的实现是在操作系统内存管理之上的，特别是托管堆的3 generations的设计，既保护了代码编写的方便性，也充分考虑了性能的优化。</p>
<p>按照MSDN文档介绍，除stackalloc运算符外，C#不提供其他任何方法来操作非托管的内存。所以这些服务通常只能由基础操作系统导入。<a href="http://msdn.microsoft.com/zh-cn/library/aa664786(v=vs.71" target="_blank" rel="external">这里的例子</a>.aspx)通过非安全代码调用系统API实现了托管堆以外的内存管理。</p>
<p>&#160;</p>
<p>转自《<a href="http://www.cnblogs.com/yangjunwl/archive/2008/01/08/1029903.html" target="_blank" rel="external">C#的内存管理：堆栈、托管堆与指针</a>》</p>
<p>在32位的Windows操作系统中，每个进程都可以使用4GB的内存，这得益于虚拟寻址技术，在C#中，虚拟内存有个两个存储变量的区域，堆栈和托管堆；堆栈存储值类型数据，每个线程都有自己的堆栈。而托管堆存储引用类型如类、对象，并受垃圾收集器的管理。当一个类对象不再被使用时，这个对象被存储在堆栈中的引用变量将被删除，但是在托管堆中的对象实例仍然存在，其空间何时被释放取决垃圾收集器。</p>
<p>在C/C++中，程序运行久了可能会产生大量的内存碎片，寻址这些碎片数据也会增加系统开销。在.NET中这种情况得到很大改善，因为垃圾收集器会压缩托管堆的内存空间，保证可用变量在一个连续的内存空间内，同时将堆栈中引用变量中的地址更新为新的地址，虽然这会带来额外的系统开销，但是，其降低了内存碎片程度和内存泄露问题。</p>
<p>另一方面，在某些时候C#程序也需要追求速度，比如对一个含用大量成员的数组操作，因为数组在C#中是System.Array的实例，会存储在托管堆中，这将会对运算造成大量的额外的操作，因为除了垃圾收集器除了会压缩托管堆、更新引用地址、还会维护托管堆的信息列表。所幸的是C#中同样能够通过使用标记为unsafe的代码块调用指针，比如声明一个存储有50个double类型的数组：</p>
<font face="Courier New"><span class="kwrd">double</span> *pDouble = <span class="kwrd">stackalloc</span> <span class="kwrd">double</span>[50];</font>

<p>垃圾收集器和堆管理系统常常涉及为提高性能而作的优化设计。举例来说，垃圾收集遍历整个内存池具有很高的开销。然而，研究表明大部分在托管堆上分配的对象只有很短的生存期，因此堆被分成三个段，称作generations。新分配的对象被放在generation 0中。这个generation是最先被回收的，在这个generation中最有可能找到不再使用的内存，由于它的尺寸很小（小到足以放进处理器的L2 cache中），因此它里面的回收将是最高效的。托管堆的另外一种优化操作与locality of reference规则有关。该规则表明，一起分配的对象经常被一起使用。如果对象们在堆中位置很紧凑的话，高速缓存的性能将会得到提高。由于托管堆的天性，对象们总是被分配在连续的地址上，使得对象们始终彼此靠近。这一点与非托管代码形成了鲜明的对比，在标准堆中，堆很容易变成碎片，而且一起分配的对象经常分得很远。还有一种优化与大对象有关，大对象堆用来放置尺寸超过85K的对象，这部分数据一般不会被GC，但当generation 2发生垃圾会收时，意味着系统可能无法分配所需的内存，这时大对象堆上也需要进行垃圾回收。</p>
<p>再说内存分配，当对象被分配的时候，它们一开始被放在generation 0中。当generation 0的大小快要达到它的上限的时候，一个只在generation 0中执行的回收操作被触发。由于其大小很小，因此这将是一个非常快的过程，其不再使用的对象将被释放，正被使用的对象被整理并移入generation 1中。当generation 1的大小随着从generation 0中移入的对象数量的增加而接近上限时，一个回收动作将会在generation 0和generation 1中执行，不再使用的对象被释放，正在被使用的对象被整理并移入下一个generation中。大部分GC过程的主要目标是generation 0，因为在generation 0中最有可能存在大量的已不再使用的临时对象。对generation 2的回收过程具有很高的开销，此过程只有在generation 0和generation 1的GC过程不能释放足够的内存时才会被触发。如果对generation 2的GC过程仍然不能释放足够的内存，那么系统就会抛出OutOfMemoryException异常。</p>
<p>当然，C#程序中也存在值类型和托管堆不能管理的对象，比如文件名柄、网络连接和数据库连接，这些变量的释放仍需要程序员通过析构函数或IDispose接口来做。对于所有拥有外部资源的类，在这些资源已经不再用到的时候，都应当执行Close或者Dispose方法。Dispose模式通过IDisposable接口来实现，需要清理外部资源的类还应当实现一个终止操作。在C#中，创建终止操作的首选方式是在析构函数中实现，而在Framework层，终止操作的实现则是通过重载System.Object.Finalize 方法。</p>
<p>带有终止操作的对象的垃圾收集过程要稍微复杂一些。当一个带有终止操作的对象被标记为垃圾时，它并不会被立即释放。相反，它会被放置在一个终止队列中，此队列为这个对象建立一个引用，来避免这个对象被回收。后台线程为队列中的每个对象执行它们各自的终止操作，并且将已经执行过终止操作的对象从终止队列中删除。只有那些已经执行过终止操作的对象才会在下一次垃圾回收过程中被从内存中删除。</p>
<p>&#160;</p>
<p>转自《<a href="http://blog.csdn.net/songkexin/article/details/5376389" target="_blank" rel="external">.NET内存分配浅析</a>》</p>
<p>这篇文章中阐述的内容大多和上一篇类似，而且文本比较差，故只摘录一小部分：</p>
<p>托管堆被触发GC的三个可能条件：</p>
<ul>
<li>1、当在托管堆上的generation 0分配内存被耗尽时（最常见），或者分配一个大对象超过了大对象堆的阀值。<em>   2、当显示调用GC.Collect()的时候。</em>   3、当操作系统的内存比较紧张时，这时操作系统会通知垃圾收集器进行GC。  </li>
</ul>
<p>&#160;</p>
<p>转自《<a href="http://www.cnblogs.com/instance/archive/2011/05/24/2056091.html" target="_blank" rel="external">原来是这样：C#中字符串的内存分配与驻留池</a>》</p>
<p>这篇文章主要是对.NET中CLR对String类内存管理上的优化处理进行分析：</p>
<p>CLR维护一个叫做驻留池（Intern Pool）的表。这个表记录了所有在代码中使用字面量声明的字符串实例的引用。使用字面量声明的字符串会进入驻留池，而其他方式声明的字符串则不会进入，也就不会自动享受到CLR防止字符串冗余的机制的好处了。请看这个例子：</p>
<font face="Courier New">StringBuilder sb = new StringBuilder();<br>sb.Append(&quot;He&quot;).Append(&quot;llo&quot;);<br>string s1 = &quot;Hello&quot;;<br>string s2 = sb.ToString();<br>bool same = (object) s1 == (object) s2;</font>

<p>这时由于s2不是通过字面量声明的，CLR在为sb.ToString()方法的返回值分配内存时，并不会到驻留池中检查是否有值为“Hello”的字符串已经存在，所以不会让s2指向驻留池内的对象。为了让编程者能够强制CLR检查驻留池，以避免冗余的字符串副本，String类的设计者提供了一个名为Intern的类方法。下面是该方法的一个示例：</p>
<font face="Courier New">StringBuilder sb = new StringBuilder();<br>sb.Append(&quot;He&quot;).Append(&quot;llo&quot;);<br>string s1 = &quot;Hello&quot;;<br>string s2 = String.Intern(sb.ToString());<br>bool same = (object) s1 == (object) s2;</font>

<p>好了，same又是true了。Intern方法接受一个字符串作为参数，它会在驻留池中检查是否存在参数所表示的字符串。如果存在，则返回那个驻留池中的字符串的引用；否则向驻留池中加入一个新的表示相同值的字符串，并返回这个字符串的引用。不过要注意的是，就算Intern方法在驻留池中找到了相同值的字符串，也不能让您省却一次字符串内存分配的操作，因为作为参数的字符串已经被分配了一次内存了。而使用Intern方法的好处在于，如果Intern方法在驻留池中找到了相同值的字符串，此时虽然在内存中存在两份该字符串的副本（一份是参数，一份是驻留池中的），但是随着时间的流逝，参数所引用的那个副本会被垃圾回收掉，这样对于该字符串内存中就不存在冗余了。</p>
<p>当您的程序中存在某个方法，可以根据不同的上下文环境创建并返回一个很长的字符串，而在程序运行的过程中它有会经常返回同样的字符串时，您可能就要考虑考虑使用Intern方法来提高内存的利用率了。不过同样值得注意的是，使用Intern方法让一个字符串存活于驻留池中也有一个副作用：即使已经不存在任何其它引用指向驻留池中的字符串了，这个字符串仍然不一定会被垃圾回收掉。也就是说即使驻留池中的字符串已经没有用处了，它可能也要等到CLR终结时才被销毁。当您使用Intern方法的时候，也应该考虑到这个特殊的行为。</p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/04/warm-up-series-3-dynamic-memory-allocation/" class="post-link">Warm Up Series (3) – Dynamic Memory Allocation</a></h2><span class="post-time">Mar 4, 2012</span><div class="post-content"><p>在摘抄完<a href="http://kevinxi.wordpress.com/2012/03/02/warm-up-series-2-process-memory-allocation/" target="_blank" rel="external">第二篇文章</a>后，我又在国外的<a href="http://www.cprogramming.com" target="_blank" rel="external">C编程网站</a>上看到了关于内存管理的系列文章，自认为比从国内论坛上东拼西凑出一套结论更有说服力，故摘抄和翻译部分内容如下：</p>
<p>&#160;</p>
<p>1. 高级内存管理（<a href="http://www.cprogramming.com/tutorial/dynamic_memory_allocation.html" target="_blank" rel="external"><font size="1">Advanced Memory Management</font></a> ）<br>在C++中不提倡使用void<em>指针，在使用多层继承时，基类中对不同子类对象看到的值可能是不一样的（多态，基类指针位置相同，但对象大小的偏移不同）。如果使用void</em>指针，则会破坏C++的多态性，这里应尽早使用dynamic_cast或者static_cast自动纠正指针指向的数据。</p>
<p>使用new[]将动态分配整数组的目标对象的内存，并调用该对象的默认构造函数，返回第一个对象的指针；使用new[]操作符时，只能够使用默认构造函数，无法调用带参数的构造函数。</p>
<p>&#160;</p>
<p>2. 动态内存分配和虚拟内存（<a href="http://www.cprogramming.com/tutorial/virtual_memory_and_heaps.html" target="_blank" rel="external"><font size="1">Dynamic Memory Allocation and Virtual Memory</font></a> ）</p>
<p>一般来说，每个进程的内存地址空间可以分为6个部分：环境区，用于保存环境变量和命令行参数；栈区，用于保存函数参数、返回值、内部变量等；堆区（自由存储区），用于动态分配内存；未初始化的静态或全局变量；初始化的静态或全局变量；代码区，加载代码的区域。</p>
<p><a href="http://kevinxi.files.wordpress.com/2012/03/image.png" target="_blank" rel="external"><img src="http://kevinxi.files.wordpress.com/2012/03/image_thumb.png" alt="image" title="image"></a></p>
<p>堆区实质上是一块连续的有碎片的内存区域。当程序请求动态内存时，系统从堆区剩余未分配的内存空间中，查找满足要求的连续内存块，并返回找到的内存区域的指针。对于堆区内存分配的算法，有的是遍历空余内存并找出最小的满足要求的内存块，有的是找出第一个满足要求的内存块。通常，系统会维护一个空闲内存的二叉数，方便快速的发现和合理分配内存。</p>
<p><a href="http://kevinxi.files.wordpress.com/2012/03/image1.png" target="_blank" rel="external"><img src="http://kevinxi.files.wordpress.com/2012/03/image_thumb1.png" alt="image" title="image"></a>    </p>
<p>3. 用new/delete自定义内存分配（<a href="http://www.cprogramming.com/tutorial/operator_new.html" target="_blank" rel="external"><font size="1">Customized Allocators with Operator New and Operator Delete</font></a> ）</p>
<p>假设你有一个链表，并且你希望提高节点内存分配的速度。那么一种可行的方法是维护一组已经被删除的节点，并且在需要添加新节点的时候重用它们的内存。在此前提下，我们可以重载new运算符，并且试图从删除的节点列表中找到可重用的节点，只有当删除的节点列表为空时，我们再真正的动态申请内存。而delete运算符则简单的将节点加入删除的节点列表中。</p>
<p>另一个重载new/delete运算符的应用是实现内存的垃圾回收，你可以实现一套类似与Java或者C#的内存回收器，这样，当你分配的内存不再被使用时，可以被自动的回收。</p>
<p>&#160;</p>
<p>4. C++常见内存管理问题（<a href="http://www.cprogramming.com/tutorial/c++_memory_problems.html" target="_blank" rel="external"><font size="1">Common Memory Management Problems in C++</font></a>）</p>
<p>这篇文章主要提供了一些检查内存泄露的工具，比如IBM的<a href="http://www-01.ibm.com/software/awdtools/purify/" target="_blank" rel="external">Purify</a>，以及建议使用自定义堆或者智能指针（标准库里面的auto_ptr）来防止内存泄露。</p>
</div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/02/warm-up-series-2-process-memory-allocation/" class="post-link">Warm Up Series (2) – Process Memory Allocation</a></h2><span class="post-time">Mar 2, 2012</span><div class="post-content"><p>C和C++编译器对内存分配的处理并不完全相同，但大致都可以分为两个部分：代码区和数据区；代码区是用来放置代码的，这部分内存在程序加载时就会被分配好；数据区根据网上很多说法，C和C++在这方面也只有很小的差别。</p>
<p>1. C程序数据区内存</p>
<p><strong>栈</strong> - 由编译器自动分配释放，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等，其操作方式类似于数据结构中的栈。通过alloca方法可以在栈上手动的分配内存，栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。不过此举并不被推荐，详见<a href="http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice" target="_blank" rel="external">此</a>文章。<br><strong>堆</strong> - 由程序分配释放，若程序不释放，在程序结束时操作系统一般会回收泄露的内存。一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。<br><strong>全局/静态区</strong> - 全局变量和静态变量的存储是在一块的，初始化的全局变量和静态变量在一块区域，未初始化的在相邻的一块区域，均在程序结束时释放。<br><strong>常量</strong> - 放置程序中的常量，程序结束时释放。</p>
<p>2. C++程序数据区内存</p>
<p><strong>栈 </strong>- 同上。<br><strong>堆 </strong>- 程序中由malloc和free来控制分配和回收的内存块，若程序不释放，在程序结束时由操作系统回收。<br><strong>自由存储区</strong> – 程序中由new和delete来控制分配和回收的内存块，若程序不释放，在程序结束时由操作系统回收。<br><strong>全局/静态区</strong> - 全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。<br><strong>常量 </strong>- 同上。</p>
<p>3. 自由存储区和堆区的区别</p>
<font color="#000000">以上内容从</font><a href="http://www.cppblog.com/zhaoyg/archive/2008/05/30/51587.html" target="_blank" rel="external"><font color="#000000">此</font></a><font color="#000000">文章整理而出，原文对C++中自由存储区和堆的介绍有错误，正确的介绍可以参考</font><a href="http://www.gotw.ca/gotw/009.htm" target="_blank" rel="external"><font color="#000000">英文原文</font></a><font color="#000000">，相关部分中文翻译如下：</font><br>  &gt; 自由存储区是C++两个动态内存区域之一，使用new和delete来予以分配和释放。在自由存储区中，对象的生存周期可以比存放它的内存区的生存周期短；也就是说，我们可以获得一片内存区而不用马上对其进行初始化；同时，在对象被销毁之后，也不用马上收回其占用的内存区。在对象被销毁而其占用的内存区还未被收回的这段时间内，我们可以通过void*的指针访问这片区域，但是其原始对象的非静态成员以及成员函数（即使我们知道了它们的地址）都不能被访问或者操纵。<br>&gt;<br>&gt; 堆区是另一个动态存储区域，使用malloc和free以及他们的变形体来进行分配和回收。要注意，虽然在特定的编译器里缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，但是堆与自由存储区是不同的——<font color="#666666">在某一个区域内被分配的内存不能在另一个区域内被安全的回收。</font>堆中被分配的内存一般用于对类对象进行placement-new的构造和explicit的析构。堆中对象的生存周期与自由存储区中的类似。<br><br><font color="#000000">C++中关于自由存储区和堆区的区别并不能统一而论，在写代码时，只要保证new-delete和malloc-free的对应关系，已经可以有效防止编译器实现差异造成的问题。</font>

<p>4. 堆区和栈区的主要区别 </p>
<p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，操作不当会产生内存泄露。 </p>
<p><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，在WINDOWS下，栈的大小是2M（VC6下默认的栈空间大小是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间，将提示栈溢出。因此，能从栈获得的空间较小。当然，这个值可以修改。 </p>
<p><strong>碎片问题</strong>：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列。 </p>
<p><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 </p>
<p><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 </p>
<p><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率比栈要低得多。</p>
<p>从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。</p>
<p>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。另外，如果有人把堆栈合起来说，那它的意思是栈，可不是堆。</p>
<p>5. new/delete与malloc/free比较</p>
<p>从C++角度上说，使用new分配堆空间<font color="#ff0000">可以调用类的构造函数</font>，而malloc()函数仅仅是一个函数调用，它不会调用构造函数，它所接受的参数是一个unsigned long类型。同样，delete在释放堆空间之前<font color="#ff0000">会调用析构函数</font>，而free函数则不会。</p>
<p>从结果可以看出，使用new/delete可以调用对象的构造函数与析构函数，并且示例中调用的是一个非默认构造函数。在堆上分配对象数组时，只能调用默认构造函数，不能调用其他任何构造函数。</p>
<p>&#160;</p>
<font color="#ff0000">Update: 关于程序内存结构的说明众说纷纭，在看了国外权威网站的英文介绍后，我认为</font><a href="http://www.diybl.com/course/3_program/c++/cppjs/20110103/552239.html" target="_blank" rel="external"><font color="#ff0000">这一篇</font></a><font color="#ff0000">中文文章的解释与英文版比较接近，另外，也可以参考</font><a href="http://www.cprogramming.com/tutorial/virtual_memory_and_heaps.html" target="_blank" rel="external"><font color="#ff0000">这篇</font></a><font color="#ff0000">英文原文。</font></div></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2012/03/02/warm-up-series-1-cc-compilation-procedure/" class="post-link">Warm Up Series (1) – C/C++ Compilation Procedure</a></h2><span class="post-time">Mar 2, 2012</span><div class="post-content"><p>转自：<a href="http://www.52rd.com/Blog/Detail_RD.Blog_hustsimoon_5196.html" target="_blank" rel="external">hustsimoon的专栏《源程序怎么变成可执行文件—初学C语言难免碰到的困惑》</a></p>
<p>&#160;</p>
<p>电子计算机所使用的是由“0”和“1”组成的二进制数，二进制是计算机的语言的基础。计算机发明之初，人们只能用计算机语言去命令计算机干这干那，写出一串串由“0”和“1”组成的指令序列交由计算机执行，这就是机器语言。</p>
<p>为了减轻使用机器语言编程的痛苦，人们进行了一种有益的改进：用一些简洁的英文字母、符号串来替代一些特定的指令的二进制串，比如，用“ADD”代表加法，“MOV”代表数据传递等，这样一来，人们很容易读懂并理解程序在干什么，纠错及维护都变得方便了，这种程序设计语言就称为汇编语言，即第二代计算机语言。然而计算机是不认识这些符号的，这就需要一个专门的程序，专门负责将这些符号翻译成二进制数的机器语言，这种翻译程序被称为汇编程序。<u>汇编指令和机器语言之间有着一一对应的关系</u>。</p>
<p>高级语言是偏向人，按照人的思维方式设计的，机器对这些可是莫名奇妙，不知所谓。于是必须要有一个桥梁来衔接两者。当你越想方便，那桥就得越复杂。那高级语言是如何变成机器语言的呢，这个过程让我慢慢道来。</p>
<p>编译：将源代码转换为机器可认识代码的过程。编译程序读取源程序（字符流），对之进行<u>词法和语法的分析</u>，<u>将高级语言指令转换为功能等效的汇编代码</u>，再由汇编程序转换为机器语言，并且按照操作系统对可执行文件格式的要求链接生成可执行程序。</p>
<font color="#ff0000">C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件</font>

<p>1. 编译预处理</p>
<p>伪指令主要包括以下四个方面</p>
<p>（1）宏定义指令，如 #define,#undef等。对于前一个伪指令，预编译所要作得的是字符串替换，注意其中字符串常量不会被替换。对于后者，则将取消对某个宏的定义，以后该串的出现将不再被替换。</p>
<p>（2）条件编译指令，如#ifdef,#ifndef,#else,#elif,#endif等等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。</p>
<p>（3）头文件包含指令，如#include &quot;xxx&quot;或者#include &lt;xxx&gt;等。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。</p>
<p>（4）特殊符号，预编译程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。</p>
<p>预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、条件编译指令、特殊符号的输出文件。这个文件的含义同没有经过预处理的源文件是相同的，但内容有所不同。下一步，此输出文件将作为编译程序的输入而被翻译成为机器指令。</p>
<p>2. 编译阶段</p>
<p>编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。</p>
<p>3.优化阶段</p>
<p>优化处理是编译系统中一项比较艰深的技术。它涉及到的问题不仅同编译技术本身有关，而且同机器的硬件环境也有很大的关系。优化一部分是对中间代码的优化。这种优化不依赖于具体的计算机。另一种优化则主要针对目标代码的生成而进行的。</p>
<p>对于前一种优化，主要的工作是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除，等等。</p>
<p>后一种类型的优化同机器的硬件结构密切相关，最主要的是考虑是如何充分利用机器的各个硬件寄存器存放的有关变量的值，以减少对于内存的访问次数。另外，根据机器硬件执行指令的特点（如流水线、RISC、CISC、VLIW等）而对指令进行一些调整使得目标代码较短，执行的效率较高。</p>
<p>4.汇编过程</p>
<p>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。</p>
<p>目标文件由段组成。通常一个目标文件中至少有两个段：</p>
<p>代码段 该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。</p>
<p>数据段 主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。</p>
<p>5.链接程序</p>
<p>由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。</p>
<p>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</p>
<p>根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：</p>
<p>（1）静态链接 在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。</p>
<p>（2）动态链接 在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。</p>
<p>对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。</p>
<p>经过上述五个过程，C源程序就最终被转换成可执行文件了。</p>
<p>&#160;</p>
<font color="#ff0000">Update: C++语言中提供了模板功能，模板实例化的过程发生在上述第二阶段，编译阶段。</font>

<p>程序员在使用模板类时最常犯的错误是将模板类视为某种数据类型。模板不是数据类型，模板就是模板；编译器使用模板，通过更换模板参数来创建数据类型，这个过程就是模板实例化；从模板类创建得到的类型称之为特例；模板实例化取决于编译器能够找到可用代码来创建特例(称之为实例化要素)；要创建特例，编译器不但要看到模板的声明，还要看到模板的定义；<u>模板实例化过程是迟钝的，即只能用函数的定义来实现实例化</u>。</p>
<p>对于传统C/C++的开发人员，一个好的习惯是将类的定义写在.h文件中，将类的实现写在.cpp文件中，这种做法在实现C++模板类时，则可以会在链接阶段遇到问题。解决问题的简单方法是将模板类的实现写成内联的形式，或者显示的实例化需要的模板实例，详细可参考<a href="http://blog.csdn.net/look01/article/details/3228134" target="_blank" rel="external">这篇</a>文章。</p>
</div></article></li></ul><div class="paginator"><a href="/page/2/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div></section><footer><div class="social"><a href="mailto:your@email.com" title="email" class="iconfont icon-email"></a><a href="/" title="github" class="iconfont icon-github"></a><a href="/atom.xml" title="rss" class="iconfont icon-rss"></a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Hao Xi</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>